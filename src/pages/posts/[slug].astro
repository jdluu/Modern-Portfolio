--- 
import BaseLayout from "../../layouts/BaseLayout.astro";
import { getCollection, render } from "astro:content";
import { resolveAssetUrl } from "../../lib/utils";

// Generate static paths from Astro content collection
export async function getStaticPaths() {
  const posts = await getCollection("posts");
  const paths = (posts ?? [])
    .filter((p: any) => p.data?.draft !== true)
    .map((p: any) => {
      const rawId = String(p.id ?? "");
      const clean = rawId.replace(/\.(md|mdx)$/, "").toLowerCase();
      return {
        params: { slug: clean },
        props: { post: p },
      };
    })
    .filter(Boolean);
  return paths;
}

// Props / derived values (receive the content entry as `post`)
const { post } = Astro.props as { post: any };

// Render the Markdown/MDX body to a Content component
const { Content } = await render(post);

// Derived and resilient values from frontmatter
const title = post?.data?.title ?? "Untitled";
const date = post?.data?.date ?? null;
const links = Array.isArray(post?.data?.links) ? post.data.links : [];
const displayDate = date
  ? new Date(date).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    })
  : "";

const heroUrl = resolveAssetUrl(post?.data?.hero) ?? null;
---

<BaseLayout title={title}>
  <link slot="head" rel="stylesheet" href="/styles/slugs/posts.css" />
  <article class="post-grid">
    <header class="post-header">
      <h1 class="post-title">{title}</h1>
      {date && <p class="publish-date">{displayDate}</p>}
    </header>

    {heroUrl && (
      <aside class="aside" aria-labelledby="post-hero">
        <figure class="hero" id="post-hero">
          <button
            type="button"
            class="hero-trigger"
            aria-label="Open image in full size"
            aria-controls="image-lightbox"
            aria-expanded="false"
          >
            <img src={heroUrl} alt={`${title} hero`} loading="lazy" decoding="async" />
          </button>
        </figure>

      </aside>
    )}

    <main class="main-content">
      <div class="prose"><Content /></div>


    </main>
 
    { links && links.length > 0 && (
      <div class="project-links" aria-label="Project links">
        <div class="links-container">
          {links
            .filter((link: any) => !!link?.url)
            .map((link: any) => (
              <a
                href={link!.url}
                target="_blank"
                rel="noopener noreferrer"
                class="project-link"
              >
                <span class="link-label">{link!.label}</span>
                <svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" width="14" height="14" class="external-icon">
                  <path fill="currentColor" d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path>
                  <path fill="currentColor" d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path>
                </svg>
              </a>
            ))}
        </div>
      </div>
    )}
 
    {heroUrl && (
      <div id="image-lightbox" class="lightbox is-hidden" hidden data-open="false" aria-hidden="true">
        <div class="lightbox-content" role="dialog" aria-modal="true" aria-label={`${title} hero image full size`} tabindex="-1">
          <img src={heroUrl} alt={`${title} hero image full size`} />
          <button class="lightbox-close" type="button" aria-label="Close image" data-close>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M18.3 5.7a1 1 0 0 0-1.4 0L12 10.6 7.1 5.7a1 1 0 0 0-1.4 1.4L10.6 12l-4.9 4.9a1 1 0 1 0 1.4 1.4L12 13.4l4.9 4.9a1 1 0 0 0 1.4-1.4L13.4 12l4.9-4.9a1 1 0 0 0 0-1.4z"/>
            </svg>
          </button>
        </div>
      </div>
    )}
  </article>

  {heroUrl && (
    <script>
      (() => {
        const lightboxEl = document.getElementById('image-lightbox');
        const trigger = document.querySelector('.hero .hero-trigger') as HTMLElement | null;
        if (!lightboxEl || !trigger) return;
  
        const triggerEl = trigger as HTMLElement; // non-nullable alias for handlers
        const lb = lightboxEl as HTMLElement;
        const content = lb.querySelector('.lightbox-content') as HTMLElement | null;
        const closeBtn = lb.querySelector('[data-close]') as HTMLElement | null;
        let lastFocusedEl: HTMLElement | null = null;
  
        function open() {
          lastFocusedEl = document.activeElement instanceof HTMLElement ? document.activeElement : null;
          lb.classList.remove('is-hidden');
          try {
            (lb as any).inert = false;
          } catch (err) {}
          lb.removeAttribute('hidden');
          lb.setAttribute('data-open', 'true');
          lb.setAttribute('aria-hidden', 'false');
          document.body.style.overflow = 'hidden';
          triggerEl.setAttribute('aria-expanded', 'true');
          if (closeBtn && typeof (closeBtn as any).focus === 'function') (closeBtn as HTMLElement).focus();
          document.addEventListener('keydown', onDocumentKeydown);
        }
  
        function close() {
          lb.classList.add('is-hidden');
          try {
            (lb as any).inert = true;
          } catch (err) {}
          lb.setAttribute('hidden', '');
          lb.setAttribute('data-open', 'false');
          lb.setAttribute('aria-hidden', 'true');
          document.body.style.overflow = '';
          triggerEl.setAttribute('aria-expanded', 'false');
          if (lastFocusedEl) lastFocusedEl.focus();
          document.removeEventListener('keydown', onDocumentKeydown);
        }
  
        function onDocumentKeydown(e: KeyboardEvent) {
          if (e.key === 'Escape' || e.key === 'Esc') {
            if (lb.getAttribute('data-open') === 'true') {
              e.preventDefault();
              close();
            }
          }
        }
  
        triggerEl.addEventListener('click', open);
  
        // Close when clicking outside the image/content or on elements with data-close
        lb.addEventListener('click', (e: Event) => {
          const evt = e as MouseEvent;
          if (!(evt.target instanceof Element)) return;
          const isBackdrop = evt.target === lb;
          const isCloseClick = !!evt.target.closest('[data-close]');
          if (isBackdrop || isCloseClick) {
            close();
          }
        });
  
        // Simple focus trap: keep focus on content while open
        lb.addEventListener('keydown', (e: KeyboardEvent) => {
          if (e.key === 'Tab' && content && lb.getAttribute('data-open') === 'true') {
            e.preventDefault();
            if (typeof (content as any).focus === 'function') (content as HTMLElement).focus();
          }
        });
      })();
    </script>
  )}
</BaseLayout>
