---
import BaseLayout from "@layouts/BaseLayout.astro";
import { getCollection, render } from "astro:content";
import { resolveAssetUrl } from "@lib/utils";
import "./posts.css";

// Generate static paths
export async function getStaticPaths() {
  const posts = await getCollection("posts");
  const paths = (posts ?? [])
    .filter((p: any) => p.data?.draft !== true)
    .map((p: any) => {
      const rawId = String(p.id ?? "");
      const clean = rawId.replace(/\.(md|mdx)$/, "").toLowerCase();
      return {
        params: { slug: clean },
        props: { post: p },
      };
    })
    .filter(Boolean);
  return paths;
}

const { post } = Astro.props as { post: any };
const { Content } = await render(post);

const title = post?.data?.title ?? "Untitled";
const date = post?.data?.date ?? null;
const links = Array.isArray(post?.data?.links) ? post.data.links : [];
const displayDate = date
  ? new Date(date).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
      timeZone: "UTC",
    })
  : "";

const heroUrl = resolveAssetUrl(post?.data?.hero) ?? null;
---

<BaseLayout title={title}>
  <article class={`post-grid ${!heroUrl ? 'no-hero' : ''}`}>
    <header class="post-header">
      <div class="post-header-content">
        <h1 class="post-title">{title}</h1>
        {date && <p class="publish-date">{displayDate}</p>}
      </div>
      <div class="post-header-actions">
        <button 
          type="button" 
          class="copy-markdown-btn" 
          aria-label="Copy post as markdown"
          title="Copy post content as markdown"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          <span class="copy-markdown-text">Copy as Markdown</span>
        </button>
      </div>
    </header>

    {heroUrl && (
      <aside class="aside" aria-labelledby="post-hero">
        <figure class="hero" id="post-hero">
          <button
            type="button"
            class="hero-trigger"
            aria-label="Open image in full size"
            aria-controls="image-lightbox"
            aria-expanded="false"
          >
            <img src={heroUrl} alt={`${title} hero`} loading="lazy" decoding="async" />
          </button>
        </figure>

      </aside>
    )}

    <main class="main-content">
      <div class="prose"><Content /></div>


    </main>
 
    { links && links.length > 0 && (
      <div class="project-links" aria-label="Project links">
        <div class="links-container">
          {links
            .filter((link: any) => !!link?.url)
            .map((link: any) => (
              <a
                href={link!.url}
                target="_blank"
                rel="noopener noreferrer"
                class="project-link"
              >
                <span class="link-label">{link!.label}</span>
                <svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" width="14" height="14" class="external-icon">
                  <path fill="currentColor" d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path>
                  <path fill="currentColor" d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path>
                </svg>
              </a>
            ))}
        </div>
      </div>
    )}
 
    {heroUrl && (
      <div id="image-lightbox" class="lightbox is-hidden" hidden data-open="false" aria-hidden="true">
        <div class="lightbox-content" role="dialog" aria-modal="true" aria-label={`${title} hero image full size`} tabindex="-1">
          <img src={heroUrl} alt={`${title} hero image full size`} />
          <button class="lightbox-close" type="button" aria-label="Close image" data-close>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M18.3 5.7a1 1 0 0 0-1.4 0L12 10.6 7.1 5.7a1 1 0 0 0-1.4 1.4L10.6 12l-4.9 4.9a1 1 0 1 0 1.4 1.4L12 13.4l4.9 4.9a1 1 0 0 0 1.4-1.4L13.4 12l4.9-4.9a1 1 0 0 0 0-1.4z"/>
            </svg>
          </button>
        </div>
      </div>
    )}
  </article>

  {heroUrl && (
    <script>
      (() => {
        const lightboxEl = document.getElementById('image-lightbox');
        const trigger = document.querySelector('.hero .hero-trigger') as HTMLElement | null;
        if (!lightboxEl || !trigger) return;
  
        const triggerEl = trigger as HTMLElement; // non-nullable alias for handlers
        const lb = lightboxEl as HTMLElement;
        const content = lb.querySelector('.lightbox-content') as HTMLElement | null;
        const closeBtn = lb.querySelector('[data-close]') as HTMLElement | null;
        let lastFocusedEl: HTMLElement | null = null;
  
        function open() {
          lastFocusedEl = document.activeElement instanceof HTMLElement ? document.activeElement : null;
          lb.classList.remove('is-hidden');
          try {
            (lb as any).inert = false;
          } catch (err) {}
          lb.removeAttribute('hidden');
          lb.setAttribute('data-open', 'true');
          lb.setAttribute('aria-hidden', 'false');
          document.body.style.overflow = 'hidden';
          triggerEl.setAttribute('aria-expanded', 'true');
          if (closeBtn && typeof (closeBtn as any).focus === 'function') (closeBtn as HTMLElement).focus();
          document.addEventListener('keydown', onDocumentKeydown);
        }
  
        function close() {
          lb.classList.add('is-hidden');
          try {
            (lb as any).inert = true;
          } catch (err) {}
          lb.setAttribute('hidden', '');
          lb.setAttribute('data-open', 'false');
          lb.setAttribute('aria-hidden', 'true');
          document.body.style.overflow = '';
          triggerEl.setAttribute('aria-expanded', 'false');
          if (lastFocusedEl) lastFocusedEl.focus();
          document.removeEventListener('keydown', onDocumentKeydown);
        }
  
        function onDocumentKeydown(e: KeyboardEvent) {
          if (e.key === 'Escape' || e.key === 'Esc') {
            if (lb.getAttribute('data-open') === 'true') {
              e.preventDefault();
              close();
            }
          }
        }
  
        triggerEl.addEventListener('click', open);
  
        // Close when clicking outside the image/content or on elements with data-close
        lb.addEventListener('click', (e: Event) => {
          const evt = e as MouseEvent;
          if (!(evt.target instanceof Element)) return;
          const isBackdrop = evt.target === lb;
          const isCloseClick = !!evt.target.closest('[data-close]');
          if (isBackdrop || isCloseClick) {
            close();
          }
        });
  
        // Simple focus trap: keep focus on content while open
        lb.addEventListener('keydown', (e: KeyboardEvent) => {
          if (e.key === 'Tab' && content && lb.getAttribute('data-open') === 'true') {
            e.preventDefault();
            if (typeof (content as any).focus === 'function') (content as HTMLElement).focus();
          }
        });
      })();
    </script>
  )}

  <script>
    // Copy as Markdown functionality
    document.addEventListener('DOMContentLoaded', function() {
      const copyBtn = document.querySelector('.copy-markdown-btn') as HTMLButtonElement;
      if (!copyBtn) return;

      copyBtn.addEventListener('click', async function() {
        try {
          const prose = document.querySelector('.prose') as HTMLElement;
          if (!prose) return;

          // Convert HTML to markdown
          const markdown = htmlToMarkdown(prose);
          
          const title = document.querySelector('.post-title')?.textContent || '';
          const date = document.querySelector('.publish-date')?.textContent || '';
          
          let fullMarkdown = '';
          if (title) {
            fullMarkdown += `# ${title}\n\n`;
          }
          if (date) {
            fullMarkdown += `*${date}*\n\n`;
          }
          fullMarkdown += markdown;

          await navigator.clipboard.writeText(fullMarkdown);
          
          // Show feedback
          copyBtn.classList.add('copied');
          setTimeout(() => {
            copyBtn.classList.remove('copied');
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          // Fallback: show error
          const originalText = copyBtn.querySelector('.copy-markdown-text')?.textContent;
          if (copyBtn.querySelector('.copy-markdown-text')) {
            (copyBtn.querySelector('.copy-markdown-text') as HTMLElement).textContent = 'Failed';
            setTimeout(() => {
              if (copyBtn.querySelector('.copy-markdown-text')) {
                (copyBtn.querySelector('.copy-markdown-text') as HTMLElement).textContent = originalText || 'Copy as Markdown';
              }
            }, 2000);
          }
        }
      });

      /**
       * Convert HTML element to markdown.
       * Recursively processes child nodes.
       */
      function htmlToMarkdown(element: HTMLElement): string {
        let markdown = '';
        const nodes = Array.from(element.childNodes);
        
        for (const node of nodes) {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent?.trim() || '';
            if (text) markdown += text + '\n\n';
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as HTMLElement;
            const tagName = el.tagName.toLowerCase();
            
            switch (tagName) {
              case 'h1':
                markdown += `# ${el.textContent?.trim() || ''}\n\n`;
                break;
              case 'h2':
                markdown += `## ${el.textContent?.trim() || ''}\n\n`;
                break;
              case 'h3':
                markdown += `### ${el.textContent?.trim() || ''}\n\n`;
                break;
              case 'h4':
                markdown += `#### ${el.textContent?.trim() || ''}\n\n`;
                break;
              case 'p':
                const pText = el.textContent?.trim() || '';
                if (pText) markdown += `${pText}\n\n`;
                break;
              case 'ul':
              case 'ol':
                const items = Array.from(el.querySelectorAll('li'));
                items.forEach((li, index) => {
                  const prefix = tagName === 'ol' ? `${index + 1}. ` : '- ';
                  const text = li.textContent?.trim() || '';
                  if (text) markdown += `${prefix}${text}\n`;
                });
                markdown += '\n';
                break;
              case 'pre':
                const code = el.querySelector('code');
                if (code) {
                  const lang = code.className.match(/language-(\w+)/)?.[1] || '';
                  const codeText = code.textContent || '';
                  markdown += `\`\`\`${lang}\n${codeText}\n\`\`\`\n\n`;
                }
                break;
              case 'code':
                if (!el.closest('pre')) {
                  markdown += `\`${el.textContent || ''}\``;
                }
                break;
              case 'blockquote':
                const quoteText = el.textContent?.trim() || '';
                if (quoteText) {
                  quoteText.split('\n').forEach(line => {
                    markdown += `> ${line}\n`;
                  });
                  markdown += '\n';
                }
                break;
              case 'hr':
                // Check if it's a section separator (multiple dashes)
                const hrText = el.textContent || '';
                if (hrText.includes('-----')) {
                  markdown += '-----\n\n';
                } else {
                  markdown += '---\n\n';
                }
                break;
              case 'strong':
              case 'b':
                markdown += `**${el.textContent || ''}**`;
                break;
              case 'em':
              case 'i':
                markdown += `*${el.textContent || ''}*`;
                break;
              case 'a':
                const href = el.getAttribute('href') || '';
                const linkText = el.textContent || '';
                markdown += `[${linkText}](${href})`;
                break;
              default:
                // Recursively process unknown elements
                markdown += htmlToMarkdown(el);
            }
          }
        }
        
        return markdown.trim();
      }
    });
  </script>
</BaseLayout>
