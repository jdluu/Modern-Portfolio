<section class="content-section homepage-intro-section">
	<div class="background-shapes" aria-hidden="true">
		<div class="shape shape1"></div>
		<div class="shape shape2"></div>
		<div class="shape shape3"></div>
	</div>

	<h2 id="home" class="page-h2">Home</h2>

	<div class="intro-content" id="intro-elements">
		<div>
			<p class="intro-greeting">Hi, I'm Jeffrey Luu</p>
			<h1 class="intro-role">Developer and Designer</h1>
			<p class="intro-tagline">Advancing technology, empowering people</p>
		</div>

		<div class="resume-button-wrapper">
			<a
				class="resume-link"
				href="https://drive.google.com/file/d/1NvgQjI2QdMaA8ZI_vNpvlE9Gw7032Ddk/view?usp=sharing"
				target="_blank"
				rel="noopener noreferrer"
				aria-label="Download Jeffrey Luuâ€™s Resume (PDF)"
			>
				Download Resume (PDF)
			</a>
		</div>
	</div>
</section>

<script>
	// Reduced-motion guard, DOM selection, and rAF-throttled parallax.
	(function () {
		const prefersReducedMotion =
			typeof window !== "undefined" &&
			window.matchMedia &&
			window.matchMedia("(prefers-reduced-motion: reduce)").matches;
	
		function initAfterPaint() {
			const hero = document.getElementById("intro-elements");
			const section = document.querySelector(".content-section");
	
			// Decorative entrance (keeps elements visible for LCP)
			if (hero) hero.classList.add("animate-hero");
	
			// Attach a lightweight, rAF-throttled parallax only when allowed
			if (!prefersReducedMotion && hero && section) {
				let rafScheduled = false;
				// Narrow the type to HTMLElement so DOM mouse properties are available
				const container = section as HTMLElement;

				// Named handler so we can remove it later (prevents leaks during client-side navigation).
				// Use the EventListener type so add/removeEventListener accept the same value.
				// We cast to PointerEvent to handle both pointer and mouse inputs.
				const onMove: EventListener = (event) => {
					if (rafScheduled) return;
					rafScheduled = true;
					const ev = event as PointerEvent;
					const clientX = ev.clientX;
					const clientY = ev.clientY;
					const rect = container.getBoundingClientRect();
					requestAnimationFrame(() => {
						const offsetX = (clientX - (rect.left + rect.width / 2)) / 50;
						const offsetY = (clientY - (rect.top + rect.height / 2)) / 50;
						// Verify hero exists before accessing style (defensive)
						if (hero && hero.style) {
							hero.style.transform = "translate(" + offsetX + "px, " + offsetY + "px)";
						}
						rafScheduled = false;
					});
				};
	
				// Attach both pointer and mouse listeners for broader device support.
				// Use passive listeners for better scroll/paint performance since we never call preventDefault().
				container.addEventListener("pointermove", onMove, { passive: true });
				container.addEventListener("mousemove", onMove, { passive: true });
	
				// Cleanup to avoid leaking listeners if the page is unloaded or hidden.
				const cleanup = function () {
					container.removeEventListener("pointermove", onMove);
					container.removeEventListener("mousemove", onMove);
					window.removeEventListener("pagehide", cleanup);
					window.removeEventListener("beforeunload", cleanup);
				};
	
				window.addEventListener("pagehide", cleanup);
				window.addEventListener("beforeunload", cleanup);
			}
		}
	
		// Run init after first paint for best LCP behavior
		if (document.readyState === "complete" || document.readyState === "interactive") {
			requestAnimationFrame(initAfterPaint);
		} else {
			document.addEventListener("DOMContentLoaded", function () {
				requestAnimationFrame(initAfterPaint);
			});
		}
	})();
</script>

